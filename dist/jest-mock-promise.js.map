{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///jest-mock-promise.js","webpack:///webpack/bootstrap 4a32f7c69b584bfe803d","webpack:///./lib/jest-mock-promise.ts","webpack:///./lib/jest-mock-promise-types.ts"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","jest_mock_promise_types_1","JestMockPromise","callbackFn","handlers","handlerIx","state","PromiseState","pending","resolveFn","bind","rejectFn","data","resolved","err","maxIx","length","el","catch","finally","callFinally","then","ex","rejected","returnedValue","callNextThen","onFulfilled","onRejected","push","onFinally","resolve","reject","console","warn","setTimeout","default"],"mappings":"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","file":"jest-mock-promise.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jest-mock-promise\"] = factory();\n\telse\n\t\troot[\"jest-mock-promise\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jest-mock-promise\"] = factory();\n\telse\n\t\troot[\"jest-mock-promise\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Synchronous Promise, which gets settled (resolved or settled) in a synchronous manner.\n *\n * `JestMockPromise` was written to simplify unit testing mocking (i.e. in [Jest](https://facebook.github.io/jest/) )\n *\n * In order to simplify synchronious promise settling two additional methods\n * were added to the promise instance:\n *   - `resolve` = forces the given promise to be resolved right away\n *   - `reject` = forces the given promise to be rejected right away\n *\n * By using these methods, we can write something like (provided that the Promise is mocked):\n *\n *    let promise = ExternalComponent.doAyncWork();\n *    promise.resolve({ label: 'this is some mock data' });\n *\n * @author   knee-cola<nikola.derezic@gmail.com>\n * @license  @license MIT License, http://www.opensource.org/licenses/MIT\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar jest_mock_promise_types_1 = __webpack_require__(1);\nvar JestMockPromise = /** @class */ (function () {\n    function JestMockPromise(callbackFn) {\n        this.handlers = [];\n        this.handlerIx = 0;\n        this.state = jest_mock_promise_types_1.PromiseState.pending;\n        // if given, calling the given function\n        if (callbackFn) {\n            callbackFn(this.resolveFn.bind(this), this.rejectFn.bind(this));\n        }\n    }\n    /**\n     * Resolves the given promise\n     * @param value data which should be passed to `then` handler functions\n     */\n    JestMockPromise.prototype.resolveFn = function (value) {\n        this.data = value;\n        this.state = jest_mock_promise_types_1.PromiseState.resolved;\n        this.err = void 0;\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx];\n            // stop the execution at first `catch` handler you run into\n            if (el.catch) {\n                break;\n            }\n            if (el.finally) {\n                this.callFinally();\n                return;\n            }\n            try {\n                // calling a `then` handler\n                value = el.then(value);\n            }\n            catch (ex) {\n                // in case `then` or a `finally` handler throws an error\n                // > pass it down to a first `catch` handler\n                this.handlerIx++;\n                this.rejectFn(ex);\n            }\n        }\n        ;\n    };\n    /**\n     * Rejects the given promise\n     * @param err error object which is to be passed as a param to `catch` function\n     */\n    JestMockPromise.prototype.rejectFn = function (err) {\n        this.state = jest_mock_promise_types_1.PromiseState.rejected;\n        this.err = err;\n        // find the first `catch` handler and call it\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx], returnedValue;\n            if (el.catch) {\n                try {\n                    returnedValue = el.catch(err);\n                    // try executing `then`/`finally` handlers which follow\n                    this.handlerIx++;\n                    this.resolveFn(returnedValue);\n                    // stop the execution as soon as you run into a first catch element\n                    break;\n                }\n                catch (ex) {\n                    // in an error was thrown within `catch` block\n                    // > pass it down to closest `catch` handler\n                    this.handlerIx++;\n                    this.rejectFn(ex);\n                    break; // the execution will continue from `rejectFn`\n                }\n            }\n            else if (el.finally) {\n                this.callFinally();\n            }\n        }\n        ;\n    };\n    /**\n     * Calls `finally` handlers\n     */\n    JestMockPromise.prototype.callFinally = function () {\n        /** is set to `true` after a successful `finally` call */\n        var callNextThen = false;\n        // find the first `finally` and call it\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx];\n            try {\n                if (el.finally) {\n                    // calling a `finally` handler\n                    el.finally(); // finally doesn't receive any data\n                    callNextThen = true; // if `then` is next - call it\n                }\n                else if (el.then && callNextThen) {\n                    // if you run into `then` right after finally > let the dedicated handler process it\n                    this.resolveFn();\n                    break; // the execution will continue from `resolveFn`\n                }\n                else if (el.catch) {\n                    callNextThen = false;\n                    continue; // skipping `catch` and search for the next `finally`\n                }\n            }\n            catch (ex) {\n                // in case `then` or a `finally` handler throws an error\n                // > pass it down to a first `catch` handler\n                this.handlerIx++;\n                this.rejectFn(ex);\n                break; // the execution will continue from `rejectFn`\n            }\n        }\n    };\n    /**\n     * Appends fulfillment and rejection handlers to the promise,\n     * and returns a new promise resolving to the return value of\n     * the called handler, or to its original settled value if the\n     * promise was not handled (i.e. if the relevant handler\n     * onFulfilled or onRejected is not a function).\n     * @param onFulfilled fulfillment handler function\n     * @param onRejected rejection handler function\n     */\n    JestMockPromise.prototype.then = function (onFulfilled, onRejected) {\n        // if the promise is already settled (resolved or rejected)\n        // > call the apropriate handler\n        switch (this.state) {\n            case jest_mock_promise_types_1.PromiseState.rejected:\n                if (onRejected) {\n                    onRejected(this.err);\n                }\n                break;\n            case jest_mock_promise_types_1.PromiseState.resolved:\n                onFulfilled(this.data);\n                break;\n            default:\n                this.handlers.push({ then: onFulfilled });\n                if (onRejected) {\n                    this.handlers.push({ catch: onRejected });\n                }\n        }\n        return (this);\n    };\n    /**\n     * Appends a rejection handler callback to the promise,\n     * and returns a new promise resolving to the return\n     * value of the callback if it is called, or to its\n     * original fulfillment value if the promise is instead\n     * fulfilled.\n     * @param onRejected rejection handler function\n     */\n    JestMockPromise.prototype.catch = function (onRejected) {\n        // if the promise is already rejected\n        // > call the handler right away\n        if (this.state === jest_mock_promise_types_1.PromiseState.rejected) {\n            onRejected(this.err);\n        }\n        else {\n            this.handlers.push({ catch: onRejected });\n        }\n        return (this);\n    };\n    /**\n     * Appends a finally handler callback to the promise\n     * @param onFinally finally handler function\n     */\n    JestMockPromise.prototype.finally = function (onFinally) {\n        // if the promise is already resolved or rejected\n        // > call the handler right away\n        if (this.state !== jest_mock_promise_types_1.PromiseState.pending) {\n            onFinally();\n        }\n        else {\n            this.handlers.push({ finally: onFinally });\n        }\n        return (this);\n    };\n    /**\n     * Resolves the promise with the given promise data.\n     * This is a non-standard method, which should be the last\n     * one to be called, after all the fulfillment and rejection\n     * handlers have been registered.\n     * @param {*} data\n     */\n    JestMockPromise.prototype.resolve = function (data) {\n        this.resolveFn(data);\n    };\n    /**\n     * Rejects the promise with the given promise with the given error object.\n     * This is a non-standard method, which should be the last\n     * one to be called, after all the fulfillment and rejection\n     * handlers have been registered.\n     * @param {*} data\n     */\n    JestMockPromise.prototype.reject = function (err) {\n        this.rejectFn(err);\n    };\n    /**\n     * Creates a resolved promise with the given data\n     * @param data data which should be passed to `then` handler functions\n     */\n    JestMockPromise.resolve = function (data) {\n        console.warn('a promise created via `JestMockPromise.resolve` will be executed async ... for sync execution call `resolve` method on an instance of `Promise`');\n        return (new JestMockPromise(function (resolve, reject) {\n            setTimeout(resolve(data), 0);\n        }));\n    };\n    /**\n     * Creates a rejected promise with the given data\n     * @param err error object which is to be passed as a param to `catch` function\n     */\n    JestMockPromise.reject = function (err) {\n        console.warn('a promise created via `JestMockPromise.reject` will be executed async ... for sync execution call `reject` method on an instance of `Promise`');\n        return (new JestMockPromise(function (resolve, reject) {\n            setTimeout(reject(err), 0);\n        }));\n    };\n    return JestMockPromise;\n}());\nexports.default = JestMockPromise;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PromiseState;\n(function (PromiseState) {\n    PromiseState[PromiseState[\"pending\"] = 0] = \"pending\";\n    PromiseState[PromiseState[\"resolved\"] = 1] = \"resolved\";\n    PromiseState[PromiseState[\"rejected\"] = 2] = \"rejected\";\n})(PromiseState || (PromiseState = {}));\nexports.PromiseState = PromiseState;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// jest-mock-promise.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4a32f7c69b584bfe803d","\"use strict\";\n/**\n * Synchronous Promise, which gets settled (resolved or settled) in a synchronous manner.\n *\n * `JestMockPromise` was written to simplify unit testing mocking (i.e. in [Jest](https://facebook.github.io/jest/) )\n *\n * In order to simplify synchronious promise settling two additional methods\n * were added to the promise instance:\n *   - `resolve` = forces the given promise to be resolved right away\n *   - `reject` = forces the given promise to be rejected right away\n *\n * By using these methods, we can write something like (provided that the Promise is mocked):\n *\n *    let promise = ExternalComponent.doAyncWork();\n *    promise.resolve({ label: 'this is some mock data' });\n *\n * @author   knee-cola<nikola.derezic@gmail.com>\n * @license  @license MIT License, http://www.opensource.org/licenses/MIT\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar jest_mock_promise_types_1 = require(\"./jest-mock-promise-types\");\nvar JestMockPromise = /** @class */ (function () {\n    function JestMockPromise(callbackFn) {\n        this.handlers = [];\n        this.handlerIx = 0;\n        this.state = jest_mock_promise_types_1.PromiseState.pending;\n        // if given, calling the given function\n        if (callbackFn) {\n            callbackFn(this.resolveFn.bind(this), this.rejectFn.bind(this));\n        }\n    }\n    /**\n     * Resolves the given promise\n     * @param value data which should be passed to `then` handler functions\n     */\n    JestMockPromise.prototype.resolveFn = function (value) {\n        this.data = value;\n        this.state = jest_mock_promise_types_1.PromiseState.resolved;\n        this.err = void 0;\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx];\n            // stop the execution at first `catch` handler you run into\n            if (el.catch) {\n                break;\n            }\n            if (el.finally) {\n                this.callFinally();\n                return;\n            }\n            try {\n                // calling a `then` handler\n                value = el.then(value);\n            }\n            catch (ex) {\n                // in case `then` or a `finally` handler throws an error\n                // > pass it down to a first `catch` handler\n                this.handlerIx++;\n                this.rejectFn(ex);\n            }\n        }\n        ;\n    };\n    /**\n     * Rejects the given promise\n     * @param err error object which is to be passed as a param to `catch` function\n     */\n    JestMockPromise.prototype.rejectFn = function (err) {\n        this.state = jest_mock_promise_types_1.PromiseState.rejected;\n        this.err = err;\n        // find the first `catch` handler and call it\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx], returnedValue;\n            if (el.catch) {\n                try {\n                    returnedValue = el.catch(err);\n                    // try executing `then`/`finally` handlers which follow\n                    this.handlerIx++;\n                    this.resolveFn(returnedValue);\n                    // stop the execution as soon as you run into a first catch element\n                    break;\n                }\n                catch (ex) {\n                    // in an error was thrown within `catch` block\n                    // > pass it down to closest `catch` handler\n                    this.handlerIx++;\n                    this.rejectFn(ex);\n                    break; // the execution will continue from `rejectFn`\n                }\n            }\n            else if (el.finally) {\n                this.callFinally();\n            }\n        }\n        ;\n    };\n    /**\n     * Calls `finally` handlers\n     */\n    JestMockPromise.prototype.callFinally = function () {\n        /** is set to `true` after a successful `finally` call */\n        var callNextThen = false;\n        // find the first `finally` and call it\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx];\n            try {\n                if (el.finally) {\n                    // calling a `finally` handler\n                    el.finally(); // finally doesn't receive any data\n                    callNextThen = true; // if `then` is next - call it\n                }\n                else if (el.then && callNextThen) {\n                    // if you run into `then` right after finally > let the dedicated handler process it\n                    this.resolveFn();\n                    break; // the execution will continue from `resolveFn`\n                }\n                else if (el.catch) {\n                    callNextThen = false;\n                    continue; // skipping `catch` and search for the next `finally`\n                }\n            }\n            catch (ex) {\n                // in case `then` or a `finally` handler throws an error\n                // > pass it down to a first `catch` handler\n                this.handlerIx++;\n                this.rejectFn(ex);\n                break; // the execution will continue from `rejectFn`\n            }\n        }\n    };\n    /**\n     * Appends fulfillment and rejection handlers to the promise,\n     * and returns a new promise resolving to the return value of\n     * the called handler, or to its original settled value if the\n     * promise was not handled (i.e. if the relevant handler\n     * onFulfilled or onRejected is not a function).\n     * @param onFulfilled fulfillment handler function\n     * @param onRejected rejection handler function\n     */\n    JestMockPromise.prototype.then = function (onFulfilled, onRejected) {\n        // if the promise is already settled (resolved or rejected)\n        // > call the apropriate handler\n        switch (this.state) {\n            case jest_mock_promise_types_1.PromiseState.rejected:\n                if (onRejected) {\n                    onRejected(this.err);\n                }\n                break;\n            case jest_mock_promise_types_1.PromiseState.resolved:\n                onFulfilled(this.data);\n                break;\n            default:\n                this.handlers.push({ then: onFulfilled });\n                if (onRejected) {\n                    this.handlers.push({ catch: onRejected });\n                }\n        }\n        return (this);\n    };\n    /**\n     * Appends a rejection handler callback to the promise,\n     * and returns a new promise resolving to the return\n     * value of the callback if it is called, or to its\n     * original fulfillment value if the promise is instead\n     * fulfilled.\n     * @param onRejected rejection handler function\n     */\n    JestMockPromise.prototype.catch = function (onRejected) {\n        // if the promise is already rejected\n        // > call the handler right away\n        if (this.state === jest_mock_promise_types_1.PromiseState.rejected) {\n            onRejected(this.err);\n        }\n        else {\n            this.handlers.push({ catch: onRejected });\n        }\n        return (this);\n    };\n    /**\n     * Appends a finally handler callback to the promise\n     * @param onFinally finally handler function\n     */\n    JestMockPromise.prototype.finally = function (onFinally) {\n        // if the promise is already resolved or rejected\n        // > call the handler right away\n        if (this.state !== jest_mock_promise_types_1.PromiseState.pending) {\n            onFinally();\n        }\n        else {\n            this.handlers.push({ finally: onFinally });\n        }\n        return (this);\n    };\n    /**\n     * Resolves the promise with the given promise data.\n     * This is a non-standard method, which should be the last\n     * one to be called, after all the fulfillment and rejection\n     * handlers have been registered.\n     * @param {*} data\n     */\n    JestMockPromise.prototype.resolve = function (data) {\n        this.resolveFn(data);\n    };\n    /**\n     * Rejects the promise with the given promise with the given error object.\n     * This is a non-standard method, which should be the last\n     * one to be called, after all the fulfillment and rejection\n     * handlers have been registered.\n     * @param {*} data\n     */\n    JestMockPromise.prototype.reject = function (err) {\n        this.rejectFn(err);\n    };\n    /**\n     * Creates a resolved promise with the given data\n     * @param data data which should be passed to `then` handler functions\n     */\n    JestMockPromise.resolve = function (data) {\n        console.warn('a promise created via `JestMockPromise.resolve` will be executed async ... for sync execution call `resolve` method on an instance of `Promise`');\n        return (new JestMockPromise(function (resolve, reject) {\n            setTimeout(resolve(data), 0);\n        }));\n    };\n    /**\n     * Creates a rejected promise with the given data\n     * @param err error object which is to be passed as a param to `catch` function\n     */\n    JestMockPromise.reject = function (err) {\n        console.warn('a promise created via `JestMockPromise.reject` will be executed async ... for sync execution call `reject` method on an instance of `Promise`');\n        return (new JestMockPromise(function (resolve, reject) {\n            setTimeout(reject(err), 0);\n        }));\n    };\n    return JestMockPromise;\n}());\nexports.default = JestMockPromise;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/jest-mock-promise.ts\n// module id = 0\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PromiseState;\n(function (PromiseState) {\n    PromiseState[PromiseState[\"pending\"] = 0] = \"pending\";\n    PromiseState[PromiseState[\"resolved\"] = 1] = \"resolved\";\n    PromiseState[PromiseState[\"rejected\"] = 2] = \"rejected\";\n})(PromiseState || (PromiseState = {}));\nexports.PromiseState = PromiseState;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/jest-mock-promise-types.ts\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}