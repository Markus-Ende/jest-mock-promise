{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 5c2c80edc15c0f97f6b5","webpack:///./lib/jest-mock-promise.ts"],"names":[],"mappings":"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","file":"jest-mock-promise.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jest-mock-promise\"] = factory();\n\telse\n\t\troot[\"jest-mock-promise\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5c2c80edc15c0f97f6b5","/**\r\n * Synchronous Promise, which gets settled (resolved or settled) in a synchronous manner.\r\n * \r\n * `JestMockPromise` was written to simplify unit testing mocking (i.e. in [Jest](https://facebook.github.io/jest/) )\r\n * \r\n * In order to simplify synchronious promise settling two additional methods\r\n * were added to the promise instance:\r\n *   - `resolve` = forces the given promise to be resolved right away\r\n *   - `reject` = forces the given promise to be rejected right away\r\n * \r\n * By using these methods, we can write something like (provided that the Promise is mocked):\r\n * \r\n *    let promise = ExternalComponent.doAyncWork();\r\n *    promise.resolve({ label: 'this is some mock data' });\r\n * \r\n * @author   knee-cola<nikola.derezic@gmail.com>\r\n * @license  @license MIT License, http://www.opensource.org/licenses/MIT\r\n * \r\n */\r\n\r\n enum PromiseState {\r\n    pending, \r\n    resolved,\r\n    rejected\r\n }\r\n\r\n type AnyFunction = (any)=>any;\r\n\r\n type HandlerType = {\r\n     then?:AnyFunction,\r\n     catch?:AnyFunction\r\n };\r\n\r\nclass JestMockPromise {\r\n\r\n    private handlers:Array<HandlerType>;\r\n    private handlerIx:number;\r\n    private data:any;\r\n    private err:any;\r\n    private state:PromiseState;\r\n\r\n    constructor(callbackFn?:(x?:any,y?:any)=>any) {\r\n\r\n        this.handlers = [];\r\n        this.handlerIx = 0;\r\n        this.state = PromiseState.pending;\r\n\r\n        // if given, calling the given function\r\n        if(callbackFn) {\r\n            callbackFn(this.resolveFn.bind(this), this.rejectFn.bind(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resolves the given promise\r\n     * @param data data which should be passed to `then` handler functions\r\n     */\r\n    private resolveFn(data:any):void {\r\n\r\n        this.data = data;\r\n        this.state = PromiseState.resolved;\r\n        this.err = void 0;\r\n\r\n        for(var maxIx=this.handlers.length; this.handlerIx<maxIx; this.handlerIx++) {\r\n            var el:HandlerType = this.handlers[this.handlerIx];\r\n            var returnedValue:any;\r\n\r\n            // stop the execution at first `catch` handler you run into\r\n            if(el.catch) {\r\n                break;\r\n            }\r\n\r\n            try {\r\n                // calling a `then` handler\r\n                returnedValue = el.then(this.data);\r\n            } catch(ex) {\r\n                // in case `then` handler throws an error\r\n                // > pass it down to a first `catch` handler\r\n                this.handlerIx++;\r\n                this.rejectFn(ex);\r\n            }\r\n            \r\n            if(returnedValue !== void 0) {\r\n            // IF handler returned a value\r\n            // > use it as the `data` for all the handlers which will be called next\r\n                this.data = returnedValue;\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Rejects the given promise\r\n     * @param err error object which is to be passed as a param to `catch` function\r\n     */\r\n    private rejectFn(err:any):void {\r\n        \r\n        this.state = PromiseState.rejected;\r\n        this.err = err;\r\n\r\n        // find the first `catch` handler and call it\r\n        for(var maxIx=this.handlers.length; this.handlerIx<maxIx; this.handlerIx++) {\r\n            var el:HandlerType = this.handlers[this.handlerIx],\r\n                returnedValue:any;\r\n\r\n            if(el.catch) {\r\n                returnedValue = el.catch(err);\r\n                // try executing `then` handlers which follow\r\n                this.handlerIx++;\r\n                this.resolveFn(returnedValue);\r\n                // stop the execution as soon as you run into a first catch element\r\n                break;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Appends fulfillment and rejection handlers to the promise,\r\n     * and returns a new promise resolving to the return value of\r\n     * the called handler, or to its original settled value if the\r\n     * promise was not handled (i.e. if the relevant handler\r\n     * onFulfilled or onRejected is not a function).\r\n     * @param onFulfilled fulfillment handler function\r\n     * @param onRejected rejection handler function\r\n     */\r\n    public then(onFulfilled:AnyFunction, onRejected?:AnyFunction):JestMockPromise {\r\n\r\n        // if the promise is already settled (resolved or rejected)\r\n        // > call the apropriate handler\r\n        switch(this.state) {\r\n            case PromiseState.rejected:\r\n                if(onRejected) {\r\n                    onRejected(this.err);\r\n                }\r\n                break;\r\n            case PromiseState.resolved:\r\n                onFulfilled(this.data);\r\n                break;\r\n            default:\r\n                this.handlers.push({ then: onFulfilled });\r\n\r\n                if(onRejected) {\r\n                    this.handlers.push({ catch: onRejected });\r\n                }\r\n        }\r\n\r\n        return(this);\r\n    }\r\n\r\n    /**\r\n     * Appends a rejection handler callback to the promise,\r\n     * and returns a new promise resolving to the return\r\n     * value of the callback if it is called, or to its\r\n     * original fulfillment value if the promise is instead\r\n     * fulfilled.\r\n     * @param onRejected rejection handler function\r\n     */\r\n    public catch(onRejected:AnyFunction) {\r\n        // if the promise is already rejected\r\n        // > call the handler right away\r\n        if(this.state === PromiseState.resolved) {\r\n            onRejected(this.err);\r\n        } else {\r\n            this.handlers.push({ catch: onRejected });\r\n        }\r\n\r\n        return(this);\r\n    }\r\n\r\n    /**\r\n     * Resolves the promise with the given promise data.\r\n     * This is a non-standard method, which should be the last\r\n     * one to be called, after all the fulfillment and rejection\r\n     * handlers have been registered.\r\n     * @param {*} data \r\n     */\r\n    public resolve(data?:any) {\r\n        this.resolveFn(data);\r\n    }\r\n\r\n    /**\r\n     * Rejects the promise with the given promise with the given error object.\r\n     * This is a non-standard method, which should be the last\r\n     * one to be called, after all the fulfillment and rejection\r\n     * handlers have been registered.\r\n     * @param {*} data \r\n     */\r\n    public reject(err?:any) {\r\n        this.rejectFn(err);\r\n    }\r\n\r\n    /**\r\n     * Creates a resolved promise with the given data\r\n     * @param data data which should be passed to `then` handler functions\r\n     */\r\n    static resolve(data?:any):JestMockPromise {\r\n        console.warn('a promise created via `JestMockPromise.resolve` will be executed async ... for sync execution call `resolve` method on an instance of `Promise`');\r\n        return(new JestMockPromise((resolve, reject) => {\r\n            setTimeout(resolve(data), 0);\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Creates a rejected promise with the given data\r\n     * @param err error object which is to be passed as a param to `catch` function\r\n     */\r\n    static reject(err?:any):JestMockPromise {\r\n        console.warn('a promise created via `JestMockPromise.reject` will be executed async ... for sync execution call `reject` method on an instance of `Promise`');\r\n        return(new JestMockPromise((resolve, reject) => {\r\n            setTimeout(reject(err), 0);\r\n        }));\r\n    };\r\n}\r\n\r\nexport default JestMockPromise;\n\n\n// WEBPACK FOOTER //\n// ./lib/jest-mock-promise.ts"],"sourceRoot":""}