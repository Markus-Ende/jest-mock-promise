{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///jest-mock-promise.js","webpack:///webpack/bootstrap 5c2c80edc15c0f97f6b5","webpack:///./lib/jest-mock-promise.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","value","PromiseState","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","JestMockPromise","callbackFn","handlers","handlerIx","state","pending","resolveFn","bind","rejectFn","data","resolved","err","maxIx","returnedValue","el","catch","then","ex","rejected","onFulfilled","onRejected","push","console","warn","resolve","reject","setTimeout","default"],"mappings":"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","file":"jest-mock-promise.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jest-mock-promise\"] = factory();\n\telse\n\t\troot[\"jest-mock-promise\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jest-mock-promise\"] = factory();\n\telse\n\t\troot[\"jest-mock-promise\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Synchronous Promise, which gets settled (resolved or settled) in a synchronous manner.\r\n *\r\n * `JestMockPromise` was written to simplify unit testing mocking (i.e. in [Jest](https://facebook.github.io/jest/) )\r\n *\r\n * In order to simplify synchronious promise settling two additional methods\r\n * were added to the promise instance:\r\n *   - `resolve` = forces the given promise to be resolved right away\r\n *   - `reject` = forces the given promise to be rejected right away\r\n *\r\n * By using these methods, we can write something like (provided that the Promise is mocked):\r\n *\r\n *    let promise = ExternalComponent.doAyncWork();\r\n *    promise.resolve({ label: 'this is some mock data' });\r\n *\r\n * @author   knee-cola<nikola.derezic@gmail.com>\r\n * @license  @license MIT License, http://www.opensource.org/licenses/MIT\r\n *\r\n */\nvar PromiseState;\n(function (PromiseState) {\n    PromiseState[PromiseState[\"pending\"] = 0] = \"pending\";\n    PromiseState[PromiseState[\"resolved\"] = 1] = \"resolved\";\n    PromiseState[PromiseState[\"rejected\"] = 2] = \"rejected\";\n})(PromiseState || (PromiseState = {}));\n\nvar JestMockPromise = function () {\n    function JestMockPromise(callbackFn) {\n        _classCallCheck(this, JestMockPromise);\n\n        this.handlers = [];\n        this.handlerIx = 0;\n        this.state = PromiseState.pending;\n        // if given, calling the given function\n        if (callbackFn) {\n            callbackFn(this.resolveFn.bind(this), this.rejectFn.bind(this));\n        }\n    }\n    /**\r\n     * Resolves the given promise\r\n     * @param data data which should be passed to `then` handler functions\r\n     */\n\n\n    _createClass(JestMockPromise, [{\n        key: \"resolveFn\",\n        value: function resolveFn(data) {\n            this.data = data;\n            this.state = PromiseState.resolved;\n            this.err = void 0;\n            for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n                var el = this.handlers[this.handlerIx];\n                var returnedValue;\n                // stop the execution at first `catch` handler you run into\n                if (el.catch) {\n                    break;\n                }\n                try {\n                    // calling a `then` handler\n                    returnedValue = el.then(this.data);\n                } catch (ex) {\n                    // in case `then` handler throws an error\n                    // > pass it down to a first `catch` handler\n                    this.handlerIx++;\n                    this.rejectFn(ex);\n                }\n                if (returnedValue !== void 0) {\n                    // IF handler returned a value\n                    // > use it as the `data` for all the handlers which will be called next\n                    this.data = returnedValue;\n                }\n            }\n            ;\n        }\n    }, {\n        key: \"rejectFn\",\n\n        /**\r\n         * Rejects the given promise\r\n         * @param err error object which is to be passed as a param to `catch` function\r\n         */\n        value: function rejectFn(err) {\n            this.state = PromiseState.rejected;\n            this.err = err;\n            // find the first `catch` handler and call it\n            for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n                var el = this.handlers[this.handlerIx],\n                    returnedValue;\n                if (el.catch) {\n                    returnedValue = el.catch(err);\n                    // try executing `then` handlers which follow\n                    this.handlerIx++;\n                    this.resolveFn(returnedValue);\n                    // stop the execution as soon as you run into a first catch element\n                    break;\n                }\n            }\n            ;\n        }\n        /**\r\n         * Appends fulfillment and rejection handlers to the promise,\r\n         * and returns a new promise resolving to the return value of\r\n         * the called handler, or to its original settled value if the\r\n         * promise was not handled (i.e. if the relevant handler\r\n         * onFulfilled or onRejected is not a function).\r\n         * @param onFulfilled fulfillment handler function\r\n         * @param onRejected rejection handler function\r\n         */\n\n    }, {\n        key: \"then\",\n        value: function then(onFulfilled, onRejected) {\n            // if the promise is already settled (resolved or rejected)\n            // > call the apropriate handler\n            switch (this.state) {\n                case PromiseState.rejected:\n                    if (onRejected) {\n                        onRejected(this.err);\n                    }\n                    break;\n                case PromiseState.resolved:\n                    onFulfilled(this.data);\n                    break;\n                default:\n                    this.handlers.push({ then: onFulfilled });\n                    if (onRejected) {\n                        this.handlers.push({ catch: onRejected });\n                    }\n            }\n            return this;\n        }\n        /**\r\n         * Appends a rejection handler callback to the promise,\r\n         * and returns a new promise resolving to the return\r\n         * value of the callback if it is called, or to its\r\n         * original fulfillment value if the promise is instead\r\n         * fulfilled.\r\n         * @param onRejected rejection handler function\r\n         */\n\n    }, {\n        key: \"catch\",\n        value: function _catch(onRejected) {\n            // if the promise is already rejected\n            // > call the handler right away\n            if (this.state === PromiseState.resolved) {\n                onRejected(this.err);\n            } else {\n                this.handlers.push({ catch: onRejected });\n            }\n            return this;\n        }\n        /**\r\n         * Resolves the promise with the given promise data.\r\n         * This is a non-standard method, which should be the last\r\n         * one to be called, after all the fulfillment and rejection\r\n         * handlers have been registered.\r\n         * @param {*} data\r\n         */\n\n    }, {\n        key: \"resolve\",\n        value: function resolve(data) {\n            this.resolveFn(data);\n        }\n        /**\r\n         * Rejects the promise with the given promise with the given error object.\r\n         * This is a non-standard method, which should be the last\r\n         * one to be called, after all the fulfillment and rejection\r\n         * handlers have been registered.\r\n         * @param {*} data\r\n         */\n\n    }, {\n        key: \"reject\",\n        value: function reject(err) {\n            this.rejectFn(err);\n        }\n        /**\r\n         * Creates a resolved promise with the given data\r\n         * @param data data which should be passed to `then` handler functions\r\n         */\n\n    }], [{\n        key: \"resolve\",\n        value: function resolve(data) {\n            console.warn('a promise created via `JestMockPromise.resolve` will be executed async ... for sync execution call `resolve` method on an instance of `Promise`');\n            return new JestMockPromise(function (resolve, reject) {\n                setTimeout(resolve(data), 0);\n            });\n        }\n        /**\r\n         * Creates a rejected promise with the given data\r\n         * @param err error object which is to be passed as a param to `catch` function\r\n         */\n\n    }, {\n        key: \"reject\",\n        value: function reject(err) {\n            console.warn('a promise created via `JestMockPromise.reject` will be executed async ... for sync execution call `reject` method on an instance of `Promise`');\n            return new JestMockPromise(function (resolve, reject) {\n                setTimeout(reject(err), 0);\n            });\n        }\n    }]);\n\n    return JestMockPromise;\n}();\n\nexports.default = JestMockPromise;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// jest-mock-promise.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5c2c80edc15c0f97f6b5","/**\r\n * Synchronous Promise, which gets settled (resolved or settled) in a synchronous manner.\r\n * \r\n * `JestMockPromise` was written to simplify unit testing mocking (i.e. in [Jest](https://facebook.github.io/jest/) )\r\n * \r\n * In order to simplify synchronious promise settling two additional methods\r\n * were added to the promise instance:\r\n *   - `resolve` = forces the given promise to be resolved right away\r\n *   - `reject` = forces the given promise to be rejected right away\r\n * \r\n * By using these methods, we can write something like (provided that the Promise is mocked):\r\n * \r\n *    let promise = ExternalComponent.doAyncWork();\r\n *    promise.resolve({ label: 'this is some mock data' });\r\n * \r\n * @author   knee-cola<nikola.derezic@gmail.com>\r\n * @license  @license MIT License, http://www.opensource.org/licenses/MIT\r\n * \r\n */\r\n\r\n enum PromiseState {\r\n    pending, \r\n    resolved,\r\n    rejected\r\n }\r\n\r\n type AnyFunction = (any)=>any;\r\n\r\n type HandlerType = {\r\n     then?:AnyFunction,\r\n     catch?:AnyFunction\r\n };\r\n\r\nclass JestMockPromise {\r\n\r\n    private handlers:Array<HandlerType>;\r\n    private handlerIx:number;\r\n    private data:any;\r\n    private err:any;\r\n    private state:PromiseState;\r\n\r\n    constructor(callbackFn?:(x?:any,y?:any)=>any) {\r\n\r\n        this.handlers = [];\r\n        this.handlerIx = 0;\r\n        this.state = PromiseState.pending;\r\n\r\n        // if given, calling the given function\r\n        if(callbackFn) {\r\n            callbackFn(this.resolveFn.bind(this), this.rejectFn.bind(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resolves the given promise\r\n     * @param data data which should be passed to `then` handler functions\r\n     */\r\n    private resolveFn(data:any):void {\r\n\r\n        this.data = data;\r\n        this.state = PromiseState.resolved;\r\n        this.err = void 0;\r\n\r\n        for(var maxIx=this.handlers.length; this.handlerIx<maxIx; this.handlerIx++) {\r\n            var el:HandlerType = this.handlers[this.handlerIx];\r\n            var returnedValue:any;\r\n\r\n            // stop the execution at first `catch` handler you run into\r\n            if(el.catch) {\r\n                break;\r\n            }\r\n\r\n            try {\r\n                // calling a `then` handler\r\n                returnedValue = el.then(this.data);\r\n            } catch(ex) {\r\n                // in case `then` handler throws an error\r\n                // > pass it down to a first `catch` handler\r\n                this.handlerIx++;\r\n                this.rejectFn(ex);\r\n            }\r\n            \r\n            if(returnedValue !== void 0) {\r\n            // IF handler returned a value\r\n            // > use it as the `data` for all the handlers which will be called next\r\n                this.data = returnedValue;\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Rejects the given promise\r\n     * @param err error object which is to be passed as a param to `catch` function\r\n     */\r\n    private rejectFn(err:any):void {\r\n        \r\n        this.state = PromiseState.rejected;\r\n        this.err = err;\r\n\r\n        // find the first `catch` handler and call it\r\n        for(var maxIx=this.handlers.length; this.handlerIx<maxIx; this.handlerIx++) {\r\n            var el:HandlerType = this.handlers[this.handlerIx],\r\n                returnedValue:any;\r\n\r\n            if(el.catch) {\r\n                returnedValue = el.catch(err);\r\n                // try executing `then` handlers which follow\r\n                this.handlerIx++;\r\n                this.resolveFn(returnedValue);\r\n                // stop the execution as soon as you run into a first catch element\r\n                break;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Appends fulfillment and rejection handlers to the promise,\r\n     * and returns a new promise resolving to the return value of\r\n     * the called handler, or to its original settled value if the\r\n     * promise was not handled (i.e. if the relevant handler\r\n     * onFulfilled or onRejected is not a function).\r\n     * @param onFulfilled fulfillment handler function\r\n     * @param onRejected rejection handler function\r\n     */\r\n    public then(onFulfilled:AnyFunction, onRejected?:AnyFunction):JestMockPromise {\r\n\r\n        // if the promise is already settled (resolved or rejected)\r\n        // > call the apropriate handler\r\n        switch(this.state) {\r\n            case PromiseState.rejected:\r\n                if(onRejected) {\r\n                    onRejected(this.err);\r\n                }\r\n                break;\r\n            case PromiseState.resolved:\r\n                onFulfilled(this.data);\r\n                break;\r\n            default:\r\n                this.handlers.push({ then: onFulfilled });\r\n\r\n                if(onRejected) {\r\n                    this.handlers.push({ catch: onRejected });\r\n                }\r\n        }\r\n\r\n        return(this);\r\n    }\r\n\r\n    /**\r\n     * Appends a rejection handler callback to the promise,\r\n     * and returns a new promise resolving to the return\r\n     * value of the callback if it is called, or to its\r\n     * original fulfillment value if the promise is instead\r\n     * fulfilled.\r\n     * @param onRejected rejection handler function\r\n     */\r\n    public catch(onRejected:AnyFunction) {\r\n        // if the promise is already rejected\r\n        // > call the handler right away\r\n        if(this.state === PromiseState.resolved) {\r\n            onRejected(this.err);\r\n        } else {\r\n            this.handlers.push({ catch: onRejected });\r\n        }\r\n\r\n        return(this);\r\n    }\r\n\r\n    /**\r\n     * Resolves the promise with the given promise data.\r\n     * This is a non-standard method, which should be the last\r\n     * one to be called, after all the fulfillment and rejection\r\n     * handlers have been registered.\r\n     * @param {*} data \r\n     */\r\n    public resolve(data?:any) {\r\n        this.resolveFn(data);\r\n    }\r\n\r\n    /**\r\n     * Rejects the promise with the given promise with the given error object.\r\n     * This is a non-standard method, which should be the last\r\n     * one to be called, after all the fulfillment and rejection\r\n     * handlers have been registered.\r\n     * @param {*} data \r\n     */\r\n    public reject(err?:any) {\r\n        this.rejectFn(err);\r\n    }\r\n\r\n    /**\r\n     * Creates a resolved promise with the given data\r\n     * @param data data which should be passed to `then` handler functions\r\n     */\r\n    static resolve(data?:any):JestMockPromise {\r\n        console.warn('a promise created via `JestMockPromise.resolve` will be executed async ... for sync execution call `resolve` method on an instance of `Promise`');\r\n        return(new JestMockPromise((resolve, reject) => {\r\n            setTimeout(resolve(data), 0);\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Creates a rejected promise with the given data\r\n     * @param err error object which is to be passed as a param to `catch` function\r\n     */\r\n    static reject(err?:any):JestMockPromise {\r\n        console.warn('a promise created via `JestMockPromise.reject` will be executed async ... for sync execution call `reject` method on an instance of `Promise`');\r\n        return(new JestMockPromise((resolve, reject) => {\r\n            setTimeout(reject(err), 0);\r\n        }));\r\n    };\r\n}\r\n\r\nexport default JestMockPromise;\n\n\n// WEBPACK FOOTER //\n// ./lib/jest-mock-promise.ts"],"sourceRoot":""}